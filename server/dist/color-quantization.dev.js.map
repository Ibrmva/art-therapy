{"version":3,"sources":["color-quantization.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA","sourcesContent":["// import { Image } from 'image-js';\n// import ndarray from 'ndarray';\n// import ops from 'ndarray-ops';\n// import savePixels from 'save-pixels';\n// import fs from 'fs';\n\n// // Global variables\n// let IMAGE_3D_MATRIX = null;\n// let K = 8; // Number of clusters for k-means (default is 8)\n\n// // Function to read an image using image-js\n// async function readImage(imageData) {\n//   let img;\n\n//   if (imageData.startsWith('data:image')) {\n//     // Handle base64 image data\n//     const base64Data = imageData.split(',')[1];  // Strip 'data:image/jpeg;base64,' part\n//     const buffer = Buffer.from(base64Data, 'base64');\n//     img = await Image.load(buffer);\n//   } else {\n//     // Handle image path\n//     img = await Image.load(imageData);\n//   }\n\n//   const pixels = img.getData();\n//   const shape = [img.height, img.width, 3];  // height, width, and 3 channels (RGB)\n//   IMAGE_3D_MATRIX = ndarray(new Float32Array(pixels), shape);\n// }\n\n// // K-means clustering function\n// function kMeans(points) {\n//   const centers = points.map(([x, y]) => [\n//     IMAGE_3D_MATRIX.get(x, y, 0),\n//     IMAGE_3D_MATRIX.get(x, y, 1),\n//     IMAGE_3D_MATRIX.get(x, y, 2),\n//   ]);\n\n//   const centersMatrix = ndarray(new Float32Array(centers.flat()), [centers.length, 3]);\n//   const classes = ndarray(new Uint8Array(IMAGE_3D_MATRIX.shape[0] * IMAGE_3D_MATRIX.shape[1]), [\n//     IMAGE_3D_MATRIX.shape[0],\n//     IMAGE_3D_MATRIX.shape[1],\n//   ]);\n\n//   for (let iter = 0; iter < 10; iter++) {\n//     IMAGE_3D_MATRIX.hi(classes.shape[0], classes.shape[1]).forEach((pixel, idx) => {\n//       const [r, c] = idx;\n//       let minDist = Infinity;\n//       let cluster = -1;\n\n//       centers.forEach((center, k) => {\n//         const dist = Math.sqrt(\n//           Math.pow(pixel[0] - center[0], 2) +\n//           Math.pow(pixel[1] - center[1], 2) +\n//           Math.pow(pixel[2] - center[2], 2)\n//         );\n//         if (dist < minDist) {\n//           minDist = dist;\n//           cluster = k;\n//         }\n//       });\n\n//       classes.set(r, c, cluster);\n//     });\n\n//     const newCenters = Array.from({ length: K }, () => [0, 0, 0]);\n//     const counts = new Array(K).fill(0);\n\n//     classes.forEach((cluster, idx) => {\n//       const [r, c] = idx;\n//       const pixel = [IMAGE_3D_MATRIX.get(r, c, 0), IMAGE_3D_MATRIX.get(r, c, 1), IMAGE_3D_MATRIX.get(r, c, 2)];\n//       newCenters[cluster][0] += pixel[0];\n//       newCenters[cluster][1] += pixel[1];\n//       newCenters[cluster][2] += pixel[2];\n//       counts[cluster]++;\n//     });\n\n//     for (let k = 0; k < K; k++) {\n//       if (counts[k] > 0) {\n//         centers[k][0] = newCenters[k][0] / counts[k];\n//         centers[k][1] = newCenters[k][1] / counts[k];\n//         centers[k][2] = newCenters[k][2] / counts[k];\n//       }\n//     }\n//   }\n\n//   // Update the image with the new quantized colors\n//   classes.forEach((cluster, idx) => {\n//     const [r, c] = idx;\n//     const color = centers[cluster];\n//     IMAGE_3D_MATRIX.set(r, c, 0, color[0]);\n//     IMAGE_3D_MATRIX.set(r, c, 1, color[1]);\n//     IMAGE_3D_MATRIX.set(r, c, 2, color[2]);\n//   });\n// }\n\n// // Function to save the quantized image as a PNG file\n// function saveImage() {\n//   savePixels(IMAGE_3D_MATRIX, 'png').pipe(fs.createWriteStream(`output_K${K}.png`));\n// }\n\n// // Main function to trigger the process\n// async function processImage(imageData) {\n//   await readImage(imageData);\n\n//   // Random starting points for K-means\n//   const points = Array.from({ length: K }, () => [\n//     Math.floor(Math.random() * IMAGE_3D_MATRIX.shape[0]),\n//     Math.floor(Math.random() * IMAGE_3D_MATRIX.shape[1]),\n//   ]);\n\n//   kMeans(points);\n//   saveImage();\n// }\n"],"file":"color-quantization.dev.js"}