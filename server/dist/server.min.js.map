{"version":3,"sources":["server.js"],"names":["_express","_interopRequireDefault","require","_cors","_dotenv","_openai","_potrace","_sharp","_mlKmeans","_expressFileupload","_vtracer","dotenv","config","app","corsOptions","origin","methods","allowedHeaders","use","express","json","limit","process","env","VITE_OPENAI_API_KEY","console","error","exit","apiKey","imgBuffer","numColors","resizedImage","pixels","i","r","g","b","result","_args","arguments","regeneratorRuntime","async","_context","prev","next","length","undefined","awrap","toFormat","raw","toBuffer","sent","OpenAI","extractDominantColors","Error","kmeans","abrupt","centroids","t0","message","stop","vectorizeImage","svg","pngBuffer","_context3","vtracer","layerDifference","mode","Buffer","from","push","flatten","background","warn","log","Promise","resolve","reject","potrace","trace","color","threshold","err","_pngBuffer","_context2","post","req","res","image","_req$body$colorOption","colorOption","processedImage","dominantColors","rawImage","segmentedPixels","_loop","_ref","width","height","_context4","status","files","data","includes","mimetype","body","parseInt","_ref2","closestColor","reduce","curr","Math","sqrt","pow","apply","_toConsumableArray","map","round","metadata","channels","toString","_req$body","prompt","_context5","isNaN","openai","images","generate","model","n","size","concat","response_format","b64_json","PORT","listen"],"mappings":"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","file":"server.min.js","sourcesContent":["import express from 'express';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport OpenAI from 'openai';\nimport potrace from 'potrace';\nimport sharp from 'sharp';\nimport { kmeans } from 'ml-kmeans'; \nimport fileUpload from 'express-fileupload'; \nimport vtracer from 'vtracer';\n\ndotenv.config();\n\nconst app = express();\n\nconst corsOptions = {\n    origin: 'http://localhost:5173',\n    methods: ['GET', 'POST'],\n    allowedHeaders: ['Content-Type'],\n};\n\napp.use(cors(corsOptions));\napp.use(express.json({ limit: '50mb' }));\napp.use(fileUpload());\n\n\nif (!process.env.VITE_OPENAI_API_KEY) {\n    console.error('Error: OPENAI_API_KEY is not defined in the .env file');\n    process.exit(1);\n}\n\nconst openai = new OpenAI({\n    apiKey: process.env.VITE_OPENAI_API_KEY,\n});\n\n\n\nconst extractDominantColors = async (imgBuffer, numColors = 24) => {\n    try {\n        const resizedImage = await sharp(imgBuffer)\n            .resize(100, 100)\n            .toFormat('raw')\n            .raw()\n            .toBuffer();\n\n        const pixels = [];\n        for (let i = 0; i < resizedImage.length; i += 3) {\n\n            const r = resizedImage[i];\n            const g = resizedImage[i + 1];\n            const b = resizedImage[i + 2];\n            pixels.push([r, g, b]);\n        }\n\n        if (pixels.length === 0) {\n            throw new Error('No valid pixel data extracted');\n        }\n\n        const result = kmeans(pixels, numColors);\n        return result.centroids;\n    } catch (error) {\n        console.error('Error extracting dominant colors:', error.message);\n        throw new Error('Failed to extract dominant colors');\n    }\n};\n\nconst vectorizeImage = async (imgBuffer) => {\n    try {\n  \n        if (!vtracer) {\n            throw new Error('vtracer is not defined');\n        }\n\n        const svg = await vtracer({\n            input: imgBuffer,\n            colorPrecision: 12,\n            layerDifference: 12,\n            mode: 'spline',\n        });\n\n        const pngBuffer = await sharp(Buffer.from(svg))\n            .toFormat('png')\n            .flatten({ background: { r: 255, g: 255, b: 255 } })\n            .toBuffer();\n        \n        return pngBuffer;\n    } catch (vtracerError) {\n        console.warn('vtracer failed:', vtracerError.message);\n        console.log('Falling back to potrace...');\n\n        return new Promise((resolve, reject) => {\n            potrace.trace(imgBuffer, { color: 'black', threshold: 128 }, async (err, svg) => {\n                if (err) {\n                    console.error('Potrace vectorization failed:', err.message);\n                    reject(new Error('Vectorization failed using both vtracer and potrace'));\n                } else {\n                    try {\n        \n                        const pngBuffer = await sharp(Buffer.from(svg))\n                            .toFormat('png')\n                            .flatten({ background: { r: 255, g: 255, b: 255 } }) // Set background to white\n                            .toBuffer();\n                        \n                        resolve(pngBuffer);\n                    } catch (svgError) {\n                        reject(new Error('Failed to convert SVG to PNG'));\n                    }\n                }\n            });\n        });\n    }\n};\n\n\n\napp.post('/segmentImage', async (req, res) => {\n    try {\n        if (!req.files || !req.files.image) {\n            return res.status(400).json({ error: 'No file uploaded' });\n        }\n\n        const { image } = req.files;\n        const imgBuffer = image.data;\n\n        const validMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/svg'];\n        if (!validMimeTypes.includes(image.mimetype)) {\n            return res.status(400).json({ error: 'Invalid file type. Only image files are allowed' });\n        }\n\n    \n        const { colorOption = '12' } = req.body;\n        if (!['vector', '12', '24', 'none'].includes(colorOption)) {\n            return res.status(400).json({ error: 'Invalid color option. Allowed values are \"vector\", \"12\", \"24\", \"none\".' });\n        }\n        \n    \n        const pngBuffer = await sharp(imgBuffer).toFormat('png').toBuffer();\n        \n        let processedImage;\n        if (colorOption === 'vector') {\n       \n            const svg = await vectorizeImage(pngBuffer);\n            processedImage = Buffer.from(svg); \n        } else if (colorOption === 'none') {\n  \n            processedImage = pngBuffer;\n        } else {\n            \n            const numColors = parseInt(colorOption, 10);\n        \n            if (numColors === 12 || numColors === 24) {\n\n                const dominantColors = await extractDominantColors(pngBuffer, numColors);\n                const rawImage = await sharp(pngBuffer).raw().toBuffer();\n                const segmentedPixels = [];\n        \n                for (let i = 0; i < rawImage.length; i += 3) {\n                    const [r, g, b] = [rawImage[i], rawImage[i + 1], rawImage[i + 2]];\n        \n                    const closestColor = dominantColors.reduce((prev, curr) => {\n                        const prevDist = Math.sqrt(Math.pow(prev[0] - r, 2) + Math.pow(prev[1] - g, 2) + Math.pow(prev[2] - b, 2));\n                        const currDist = Math.sqrt(Math.pow(curr[0] - r, 2) + Math.pow(curr[1] - g, 2) + Math.pow(curr[2] - b, 2));\n                        return prevDist < currDist ? prev : curr;\n                    });\n        \n                    segmentedPixels.push(...closestColor.map(Math.round));\n                }\n        \n                const { width, height } = await sharp(pngBuffer).metadata();\n                \n                processedImage = await sharp(Buffer.from(segmentedPixels), { raw: { width, height, channels: 3 } })\n                    .toFormat('png')\n                    .toBuffer();\n            }\n        }\n        \n        res.status(200).json({ image: processedImage.toString('base64') });\n    } catch (error) {\n        console.error('Error segmenting image:', error.message);\n        res.status(500).json({ error: 'Failed to segment image', message: error.message });\n    }\n});\n\n\n\napp.post('/generateImage', async (req, res) => {\n    const { prompt, height, width } = req.body;\n\n    if (!prompt || typeof prompt !== 'string') {\n        return res.status(400).json({ error: \"Invalid or missing 'prompt' in request body\" });\n    }\n\n    if (!height || isNaN(height) || height <= 0) {\n        return res.status(400).json({ error: \"Invalid 'height' in request body\" });\n    }\n\n    if (!width || isNaN(width) || width <= 0) {\n        return res.status(400).json({ error: \"Invalid 'width' in request body\" });\n    }\n\n    try {\n        const image = await openai.images.generate({\n            prompt,\n            model: 'dall-e-3',\n            n: 1,\n            size: `${width}x${height}`,\n            response_format: 'b64_json',\n        });\n\n        res.status(200).json({ image: image.data[0].b64_json });\n    } catch (error) {\n        console.error('Error generating image:', error.message);\n        res.status(500).json({ error: 'Failed to generate image', message: error.message });\n    }\n});\n\napp.use((err, req, res, next) => {\n    console.error('Internal server error:', err);\n    res.status(500).json({ error: 'Internal server error', message: err.message });\n});\n\nconst PORT = process.env.PORT || 4000;\napp.listen(PORT, () => {\n    console.log(`Server is running on http://localhost:${PORT}`);\n});\n"]}