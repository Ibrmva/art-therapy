{"version":3,"sources":["imageProcessor.js"],"names":["require","Image","ndarray","savePixels","getPixels","RUN_MODE","K","split","IMAGE_3D_MATRIX","cluster_points","centers","i","length","Math","floor","red","get","kmeans_main","blue","green","Float32Array","flat","shape","j","classes","distances","pick","undefined","centersArray","ops","subseq","powseq","addeq","sqrtscaleeq","r","c","minClass","l","distance","minDistance","set","classIndices","cc","push","classIndicesArray","classGreens","classBlues","muleq","sumRed","sum","classReds","sumGreen","sumBlue","classIndex","console","log","concat","kmeans_with_click","points","getRandomInt","x","y","kmeans_with_random","read_image","Promise","resolve","reject","err","pixels","handle_arguments","args","process","argv","slice","error","PATH_TO_FILE","exit","allowedKValues","includes","parseInt","pipe","createWriteStream","on","save_image","min","max","random","main","data","imageArray","b","regeneratorRuntime","async","_context","prev","next","awrap","sent","t0","stop"],"mappings":"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","file":"imageProcessor.min.js","sourcesContent":["\nconst {Image} = require('image-js');\nconst ndarray = require('ndarray');\nconst ops = require('ndarray-ops');\nconst savePixels = require('save-pixels');\nconst split = require('split-array');\nconst getPixels = require('get-pixels');\n\nlet RUN_MODE = -1;\nlet PATH_TO_FILE = \"\";\nlet K = -1;\nlet IMAGE = [];\nlet IMAGE_3D_MATRIX = null;\n\n\nfunction kmeans_main(cluster_points) {\n  // rounding pixel values and getting cluster RGB\n  const centers = [];\n  for (let i = 0; i < cluster_points.length; i++) {\n    cluster_points[i] = [Math.floor(cluster_points[i][0]), Math.floor(cluster_points[i][1])];\n    const red = IMAGE_3D_MATRIX.get(cluster_points[i][0], cluster_points[i][1], 0);\n    const green = IMAGE_3D_MATRIX.get(cluster_points[i][0], cluster_points[i][1], 1);\n    const blue = IMAGE_3D_MATRIX.get(cluster_points[i][0], cluster_points[i][1], 2);\n    centers.push([red, green, blue]);  // Ensure RGB order\n  }\n\n  const centersArray = ndarray(new Float32Array(centers.flat()), [centers.length, 3]);\n\n  // Initializing class and distance arrays\n  const classes = ndarray(new Float32Array(IMAGE_3D_MATRIX.shape[0] * IMAGE_3D_MATRIX.shape[1]), [IMAGE_3D_MATRIX.shape[0], IMAGE_3D_MATRIX.shape[1]]);\n  const distances = ndarray(new Float32Array(IMAGE_3D_MATRIX.shape[0] * IMAGE_3D_MATRIX.shape[1] * K), [IMAGE_3D_MATRIX.shape[0], IMAGE_3D_MATRIX.shape[1], K]);\n\n  for (let i = 0; i < 10; i++) {\n    // finding distances for each center\n    for (let j = 0; j < K; j++) {\n      ops.sub(distances.pick(undefined, undefined, j), centersArray.pick(undefined, undefined, 0), IMAGE_3D_MATRIX.pick(undefined, undefined, 0));\n      ops.subseq(distances.pick(undefined, undefined, j), centersArray.pick(undefined, undefined, 1), IMAGE_3D_MATRIX.pick(undefined, undefined, 1));\n      ops.subseq(distances.pick(undefined, undefined, j), centersArray.pick(undefined, undefined, 2), IMAGE_3D_MATRIX.pick(undefined, undefined, 2));\n      ops.powseq(distances.pick(undefined, undefined, j), distances.pick(undefined, undefined, j), 2);\n      ops.addeq(distances.pick(undefined, undefined, j), distances.pick(undefined, undefined, j));\n      ops.sqrtscaleeq(distances.pick(undefined, undefined, j), distances.pick(undefined, undefined, j), 1);\n    }\n\n    // choosing the minimum distance class for each pixel\n    for (let r = 0; r < classes.shape[0]; r++) {\n      for (let c = 0; c < classes.shape[1]; c++) {\n        let minDistance = Number.MAX_VALUE;\n        let minClass = 0;\n        for (let l = 0; l < K; l++) {\n          const distance = distances.get(r, c, l);\n          if (distance < minDistance) {\n            minDistance = distance;\n            minClass = l;\n          }\n        }\n        classes.set(r, c, minClass);\n      }\n    }\n\n    // rearranging centers\n    for (let c = 0; c < K; c++) {\n      const classIndices = [];\n      for (let r = 0; r < classes.shape[0]; r++) {\n        for (let cc = 0; cc < classes.shape[1]; cc++) {\n          if (classes.get(r, cc) === c) {\n            classIndices.push([r, cc]);\n          }\n        }\n      }\n      const classIndicesArray = ndarray(new Float32Array(classIndices.flat()), [classIndices.length, 2]);\n      const classReds = ndarray(new Float32Array(classIndices.length), [classIndices.length]);\n      const classGreens = ndarray(new Float32Array(classIndices.length), [classIndices.length]);\n      const classBlues = ndarray(new Float32Array(classIndices.length), [classIndices.length]);\n      \n      ops.muleq(classReds, IMAGE_3D_MATRIX.pick(undefined, undefined, 0), classIndicesArray.pick(undefined, 0));\n      ops.muleq(classGreens, IMAGE_3D_MATRIX.pick(undefined, undefined, 1), classIndicesArray.pick(undefined, 0));\n      ops.muleq(classBlues, IMAGE_3D_MATRIX.pick(undefined, undefined, 2), classIndicesArray.pick(undefined, 0));\n      \n      const sumRed = ops.sum(classReds);\n      const sumGreen = ops.sum(classGreens);\n      const sumBlue = ops.sum(classBlues);\n      \n      centersArray.set(c, 0, sumRed / classIndices.length);\n      centersArray.set(c, 1, sumGreen / classIndices.length);\n      centersArray.set(c, 2, sumBlue / classIndices.length);\n    }\n  }\n\n  // changing values with respect to class centers\n  for (let r = 0; r < IMAGE_3D_MATRIX.shape[0]; r++) {\n    for (let c = 0; c < IMAGE_3D_MATRIX.shape[1]; c++) {\n      const classIndex = classes.get(r, c);\n      IMAGE_3D_MATRIX.set(r, c, 0, centersArray.get(classIndex, 0));\n      IMAGE_3D_MATRIX.set(r, c, 1, centersArray.get(classIndex, 1));\n      IMAGE_3D_MATRIX.set(r, c, 2, centersArray.get(classIndex, 2));\n    }\n  }\n}\n\n\nfunction kmeans_with_click() {\n  const points = [];  \n  console.log(\"Click K times on the image to select points:\");\n  for (let i = 0; i < K; i++) {\n    console.log(`Click point ${i + 1}:`);\n    \n    // simulate getting point from user input\n    const x = getRandomInt(0, IMAGE_3D_MATRIX.shape[0]);\n    const y = getRandomInt(0, IMAGE_3D_MATRIX.shape[1]);\n\n    points.push([x, y]);\n  }\n  \n  kmeans_main(points);\n}\n\n\nfunction kmeans_with_random() {\n  const points = [];\n  for (let i = 0; i < K; i++) {\n    const x = getRandomInt(0, IMAGE_3D_MATRIX.shape[0]);\n    const y = getRandomInt(0, IMAGE_3D_MATRIX.shape[1]);\n    points.push([x, y]);\n  }\n  \n  kmeans_main(points);\n}\n\n\nfunction read_image() {\n  return new Promise((resolve, reject) => {\n    getPixels(PATH_TO_FILE, (err, pixels) => {\n      if (err) reject(err);\n      resolve(pixels);\n    });\n  });\n}\n\n\nfunction handle_arguments() {\n  const args = process.argv.slice(2);\n  if (args.length < 3) {\n    console.error(\"Usage: node color-quantization.js [Image Path] [K value] [Run Mode]\");\n    process.exit(1);\n  }\n\n  PATH_TO_FILE = args[0];\n  K = parseInt(args[1]);\n  RUN_MODE = parseInt(args[2]);\n\n  const allowedKValues = [1, 12, 24];\n  if (!allowedKValues.includes(K)) {\n    console.error(`Only K values of ${allowedKValues} are allowed. Your value is ${K}`);\n    process.exit(1);\n  }\n\n  if (![0, 1].includes(RUN_MODE)) {\n    console.error(\"Program mode should be either 0 or 1\");\n    process.exit(1);\n  }\n}\n\n\nfunction save_image() {\n  const stream = savePixels(IMAGE_3D_MATRIX, 'png').pipe(require('fs').createWriteStream(`output_K${K}.png`));\n  stream.on('finish', () => {\n    console.log(\"Success: Output file generated!\");\n    process.exit(0);\n  });\n}\n\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n\nasync function main() {\n  handle_arguments();\n\n  try {\n    const pixels = await read_image();\n    const shape = [pixels.shape[0], pixels.shape[1], 3];\n    const data = new Float32Array(pixels.shape[0] * pixels.shape[1] * 3);\n    const imageArray = ndarray(data, shape);\n\n    for (let r = 0; r < shape[0]; r++) {\n      for (let c = 0; c < shape[1]; c++) {\n        for (let b = 0; b < shape[2]; b++) {\n          imageArray.set(r, c, b, pixels.get(r, c, b))\n        }\n      }\n    }\n\n    IMAGE_3D_MATRIX = imageArray;\n\n    if (RUN_MODE === 1) {\n      kmeans_with_random();\n    } else {\n      await kmeans_with_click();\n    }\n\n    save_image();\n  } catch (error) {\n    console.error(error);\n    process.exit(1);\n  }\n}\n\nmain();"]}