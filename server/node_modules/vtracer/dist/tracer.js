'use strict';

// Config-----------------------------------------------------------------------

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setConfig = setConfig;
exports.v = v;
exports.d = d;
exports.i = i;
exports.w = w;
exports.e = e;
exports.logv = logv;
exports.logd = logd;
exports.logi = logi;
exports.logw = logw;
exports.loge = loge;
exports.isUsingWs = isUsingWs;
exports.isUsingHttp = isUsingHttp;
var defaultConfig = {
  serverUrl: 'ws://localhost:3065', //guess default server
  bundle: '',
  onConnectedMessage: null,
  debug: false
};
var config = void 0;
var shouldUseWs = void 0;
var shouldUseHttp = void 0;
setConfig(defaultConfig, true);

function setConfig(_config) {
  var isInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!_config.serverUrl) selfLog('vtracer warning: config.serverUrl=' + config.serverUrl);

  setConfigInstant = Date.now();

  config = {};
  for (var key in defaultConfig) {
    config[key] = defaultConfig[key];
  }
  for (var _key in _config) {
    config[_key] = _config[_key];
  }

  shouldUseWs = config.serverUrl.indexOf('ws://') != -1;
  shouldUseHttp = config.serverUrl.indexOf('http://') != -1 || config.serverUrl.indexOf('https://') != -1;

  if (!isInit) correctWsState();
}

// function shouldUseWs() {return config.serverUrl.indexOf('ws://') != -1}
// function shouldUseHttp() {return config.serverUrl.indexOf('http://') != -1 || config.serverUrl.indexOf('https://') != -1}
//------------------------------------------------------------------------------

function selfLog() {
  var _console;

  if (config.debug) (_console = console).log.apply(_console, arguments);
}

//Main API------------------------------------------------------------------------------
exports.default = {
  setConfig: setConfig, isConnected: isConnected,
  v: v, d: d, i: i, w: w, e: e,
  logv: logv, logd: logd, logi: logi, logw: logw, loge: loge,
  isUsingWs: isUsingWs, isUsingHttp: isUsingHttp
};
function v() {
  logv.apply(undefined, arguments);
}
function d() {
  logd.apply(undefined, arguments);
}
function i() {
  logi.apply(undefined, arguments);
}
function w() {
  logw.apply(undefined, arguments);
}
function e() {
  loge.apply(undefined, arguments);
}
function logv() {
  for (var _len = arguments.length, messages = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    messages[_key2] = arguments[_key2];
  }

  send.apply(undefined, ['v', Date.now()].concat(messages));
}
function logd() {
  for (var _len2 = arguments.length, messages = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
    messages[_key3] = arguments[_key3];
  }

  send.apply(undefined, ['d', Date.now()].concat(messages));
}
function logi() {
  for (var _len3 = arguments.length, messages = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
    messages[_key4] = arguments[_key4];
  }

  send.apply(undefined, ['i', Date.now()].concat(messages));
}
function logw() {
  for (var _len4 = arguments.length, messages = Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
    messages[_key5] = arguments[_key5];
  }

  send.apply(undefined, ['w', Date.now()].concat(messages));
}
function loge() {
  for (var _len5 = arguments.length, messages = Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
    messages[_key6] = arguments[_key6];
  }

  send.apply(undefined, ['e', Date.now()].concat(messages));
}
function isUsingWs() {
  return shouldUseWs;
}
function isUsingHttp() {
  return shouldUseHttp;
}

function send(level, instant) {
  for (var _len6 = arguments.length, messages = Array(_len6 > 2 ? _len6 - 2 : 0), _key7 = 2; _key7 < _len6; _key7++) {
    messages[_key7 - 2] = arguments[_key7];
  }

  var text = messages.map(function (m) {
    if (typeof m === 'string') return m;else return jsonStringify(m);
  }).join(', ');

  var payload = {
    bundle: config.bundle,
    instant: instant,
    level: level,
    text: text
  };

  if (shouldUseWs) {
    var parcel = { 'type': 'trace', payload: payload };
    var jtrace = jsonStringify(parcel);
    var successful = sendByWs(jtrace);
    if (!successful && numFailedConnectAttempts > 0) {
      selfLog('vtracer sending by ws error, serverUrl: ' + config.serverUrl);
      console.log('[vtracer fallback]' + payload.level + ': ' + payload.text); //fallback to console.log
    }
  } else {
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onprogress = function () {
      if (xmlhttp.status != 200) {
        selfLog('vtracer sending by http error, serverUrl: ' + config.serverUrl, xmlhttp);
        console.log('[vtracer fallback]' + payload.level + ': ' + payload.text); //fallback to console.log
      }
    };
    xmlhttp.open('POST', config.serverUrl + '/traces');
    xmlhttp.setRequestHeader('Content-Type', 'application/json');
    xmlhttp.send(jsonStringify(payload));
  }
}

//WebSocket------------------------------------------------------------------------------
function sendByWs(jtrace) {
  var sendSuccessful = false;
  if (isConnected()) {
    try {
      webSocket.send(jtrace);
      sendSuccessful = true;
    } catch (e) {
      selfLog('vtracer send error: event=' + e);
    }
  }

  if (!sendSuccessful) {
    if (pendingTraces.length >= MAX_PENDING_LENGTH) pendingTraces.splice(0, 1); //remove first element
    pendingTraces.push(jtrace);
    selfLog('pushing trace to pendingtraces array, length=' + pendingTraces.length);
    if (!isConnected() && !isConnecting() && !reconnectTimeout) doConnect();
  }
  lastSendInstant = Date.now();
  return sendSuccessful;
}

var webSocket = null;
var lastSendInstant = 0;
var pendingTraces = [];
var numFailedConnectAttempts = 0;
var reconnectTimeout = null;
var setConfigInstant = null;
var MAX_PENDING_LENGTH = 100;

function isConnected() {
  return webSocket && webSocket.readyState == WebSocket.OPEN;
}
function isDisconnected() {
  return !webSocket || webSocket.readyState == WebSocket.CLOSED;
}
function isConnecting() {
  return webSocket && webSocket.readyState == WebSocket.CONNECTING;
}
function isDisconnecting() {
  return webSocket && webSocket.readyState == WebSocket.CLOSING;
}

function correctWsState() {
  if (shouldUseHttp && !webSocket) return;

  if (shouldUseWs) {
    if (webSocket && webSocket.url != config.serverUrl) doConnect();else if (isDisconnected()) doConnect();
  } else {
    doDisconnect();
  }
}

function doConnect() {
  // selfLog('doConnect', config.serverUrl)
  if (config.serverUrl == null) {
    selfLog('vtracer error: cannot connect because config.serverUrl is null');
    return;
  }

  clearTimeout(reconnectTimeout);
  reconnectTimeout = null;
  doDisconnect();
  webSocket = new WebSocket(config.serverUrl);

  webSocket.onopen = function (event) {
    selfLog('vtracer websocket.onopen', webSocket);
    numFailedConnectAttempts = 0;

    if (config.onConnectedMessage) send('v', setConfigInstant, config.onConnectedMessage);

    while (pendingTraces.length > 0) {
      if (!isConnected()) break;
      var jtrace = pendingTraces.splice(0, 1)[0]; //splice preserves the array object with an element missing, so i dont need to reassign
      var success = sendByWs(jtrace);
      if (!success) break;
    }
  };
  webSocket.onclose = function (event) {
    webSocket = null;
    selfLog('vtracer websocket.onclose, code=' + event.code + ', reason=' + event.reason + ', message=' + event.message);

    if (shouldUseWs) {
      numFailedConnectAttempts++;
      var timeout = numFailedConnectAttempts <= 1 ? 2000 : 60000; //we will always try to reconnect
      reconnectTimeout = setTimeout(function () {
        return doConnect();
      }, timeout);
    }
  };
  // webSocket.onmessage = (event) => {

  // }
  webSocket.onerror = function (event) {
    selfLog('vtracer Socket Error: event=' + jsonStringify(event));
  };
}

function doDisconnect() {
  if (isConnected() || isConnecting()) {
    webSocket.close();
    webSocket = null;
  }
}

function jsonStringify(o) {
  try {
    return JSON.stringify(o, jsonStringifyHandler);
  } catch (e) {
    return e.message;
  }
}

function jsonStringifyHandler(key, val) {
  if (typeof val === 'function') {
    return val + ''; // implicitly `toString` it
  }
  // else if(typeof val === 'object') {
  //   return val + ''
  // }
  return val;
}